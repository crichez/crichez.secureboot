---
# We need to go from all possble states to a single DER-encoded cert.
# If the caller provides a private key path, we should always check it,
# and optionally generate it if it does not exist.
- name: Get a private key
  when:
    - mok_private_key is defined
  become: "{{ mok_become_pk }}"
  become_user: "{{ mok_private_key.owner }}"
  community.crypto.openssl_privatekey:
    path: "{{ mok_private_key.path }}"
    type: RSA
    size: 2048
    regenerate: fail
    owner: "{{ mok_private_key.owner }}"
    group: "{{ mok_private_key.group }}"
    mode: "{{ mok_private_key.group }}"

- name: Get a certificate
  vars:
    der_path: "{{ 0 | ansible.builtin.splitext(mok_certificate.path) }}.der }}"
  become: "{{ mok_become_cert }}"
  become_user: "{{ mok_certificate.owner }}"
  block:
    - name: Try to convert a certificate at the provided path
      community.crypto.x509_certificate_convert:
        src_path: "{{ mok_certificate.path }}"
        dest_path: "{{ der_path }}"
        format: der
        owner: "{{ mok_certificate.owner }}"
        group: "{{ mok_certificate.group }}"
        mode: "{{ mok_certificate.mode }}"
      register: convert
      ignore_errors: true

    - name: Generate a new certificate
      when:
        - convert is failed
        - mok_private_key is defined
      block:
        - name: Generate a PEM certificate first
          community.crypto.x509_certificate:
            path: "{{ mok_certificate.path }}"
            provider: selfsigned
            privatekey_path: "{{ mok_private_key.path }}"
            owner: "{{ mok_certificate.owner }}"
            group: "{{ mok_certificate.group }}"
            mode: "{{ mok_certificate.mode }}"

        - name: Convert it to DER
          community.crypto.x509_certificate_convert:
            src_path: "{{ mok_certificate.path }}"
            dest_path: "{{ der_path }}"
            format: der
            owner: "{{ mok_certificate.owner }}"
            group: "{{ mok_certificate.group }}"
            mode: "{{ mok_certificate.mode }}"

- name: Check the enrollment status of the certificate
  become: true
  ansible.builtin.command:
    argv:
      - mokutil
      - -t
      - "{{ der_path }}"
  changed_when: false
  register: test
  failed_when:
    - test.stdout is not ansible.builtin.match(mok_enrolled_regex)
    - test.stdout is not ansible.builtin.match(mok_not_enrolled_regex)
    - test.stdout is not ansible.builtin.match(mok_already_req_regex)

- name: Enroll the certificate
  become: true
  when:
    - mok_state == "enrolled"
    - test.stdout is ansible.builtin.match(mok_not_enrolled_regex)
    - ansible_check_mode is False
  block:
    - name: Prompt for an enrollment passphrase
      ansible.builtin.pause:
        prompt: true
        echo: false
      register: password_prompt

    - name: Try to enroll the MOK
      ansible.builtin.command:
        cmd: |
          spawn /usr/bin/mokutil --import {{ der_path }}
          expect "input password:"
          send -- "{{ password_prompt.user_input }}\n"
          expect "input password again:"
          send -- "{{ password_prompt.user_input }}\n"
          expect eof
        executable: /usr/bin/expect
      changed_when: true

- name: Reboot
  when:
    - mok_state == "enrolled"
    - test.stdout is ansible.builtin.match(mok_not_enrolled_regex) or
      test.stdout is ansible.builtin.match(mok_already_req_regex)
  block:
    - name: Warn about manual steps required
      ansible.builtin.debug:
        msg: >
          A new Machine Owner Key (MOK) was enrolled. Before this playbook can
          continue, the import will need to be manually validated in a program
          called MokManager. This will happen automatically when the machine is
          rebooted, but requires an admin with access to a local console.

          MokManager is very easy to use. Once in the menu select "Enroll MOK,"
          enter the same password you just provided, and reboot. This playbook
          will resume when the host is back online, or will automatically fail
          after ten minutes. If something strange happens, just run the play
          again.

    - name: Prompt for a reboot
      ansible.builtin.pause:
        prompt: Ready to reboot? (y/n)
        echo: true
      register: reboot_prompt
      changed_when: false
      failed_when:
        - reboot_prompt.user_input != "y"
        - reboot_prompt.user_input != "Y"

    - name: Reboot
      become: true
      ansible.builtin.reboot:

    - name: Check the enrollment status of the certificate again
      become: true
      ansible.builtin.command:
        argv:
          - mokutil
          - -t
          - "{{ der_path }}"
      changed_when: false
      register: test
      failed_when:
        - test.stdout is not ansible.builtin.match(mok_enrolled_regex)
